package simple;

import java.math.BigDecimal;

public class DifferentPathNumOne {

    public static void main(String[] args) {
        System.out.println(uniquePathsMath(59, 5));
    }

    public static int uniquePaths(int m, int n) {
        // write code here
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * @param m
     * @param n
     * @return int
     * @description 这段Java代码实现的是计算组合数(Combination)的逻辑，具体是计算C(m+n-2, n-1)的值，这里采用了一种减少乘法和除法次数的优化方法，适用于当一个组合数的上标(或下标)远大于另一个时，可以减少计算中的整数溢出风险。下面是详细的逻辑解析：
     * 初始化:
     * 首先，定义并初始化一个长整型变量ret为1。这个变量将用来累计计算组合数的结果。
     * 循环变量设置:
     * 设置两个循环变量：x初始化为n，y初始化为1。这里的x和y实质上代表了组合公式中分母和分子的一部分，但通过循环逐步更新，实际上是在动态计算组合数的值。
     * 循环逻辑:
     * 循环的条件是y < m，意味着循环会执行(m-1)次，这对应于从(m+n-2)个位置中选择(n-1)个位置（或等效地，(m-1)次向下移动）的所有可能组合。
     * 在每次循环中，ret的值通过ret = ret * x / y更新。这个操作实际上是逐步构建组合数的分子和分母，但由于直接在累积结果上进行操作，避免了单独计算分子和分母的大数问题。
     * 每次循环后，x增加1，代表向右的步数累加；同时y也增加1，代表向下步数的累加，这与组合数的计算逻辑相符。
     * 结果转换与返回:
     * 循环结束后，将长整型变量ret转换成整型并返回。这是因为路径数量是一个非负整数，且在大多数情况下，计算结果应该能够安全地转换为整型。
     * 这种方法有效地减少了实际的乘除运算次数，并且在处理大数时比直接计算阶乘再相除的方式更稳定，降低了溢出的风险。整个逻辑基于组合数学中的性质，巧妙地通过迭代更新累乘结果来实现组合数的计算。
     * <p>
     * <p>
     * <p>
     * <p>
     * x初始化为n，每次循环加一，为什么代表向右的步数累加？
     * 在理解这个问题时，我们需要回顾一下组合问题的背景和这个特定函数的目的。该函数是用来计算一个m×n网格中，从左上角到右下角的不同行走路径数量。每一步只能向右或向下移动。
     * 当我们计算组合数C(m+n-2, n-1)时，这个表达式实际上是在寻找从(m+n-2)次移动中选择(n-1)次向下的方式数，剩下的(m-1)次自然就是向右的移动。但是，直接这么看可能与x的递增关联不明显，我们换个角度解释：
     * 初始时，x = n，可以理解为“起点”配置。因为我们是从(m+n-2)次总移动中选择，而这个总数已经隐含了起点（左上角）到终点（右下角）所需的最少步数，所以实际上是从第n次移动（即第一个可选的向右移动机会，因为在到达第一行的最右边之前，你必须至少向下走n-1次）开始考虑的。
     * 随着循环进行，x每次增加1，实际上就是在累加“额外的”向右移动次数。因为每次循环也同时增加了向下的移动次数（y递增），但我们的重点在于理解x的增长如何关联到向右移动。在这个上下文中，x的增长反映了在保证至少有(n-1)次向下移动的前提下，额外增加的向右移动机会。
     * 因此，虽然直接从代码中看x的递增可能不易直观联想到“向右的步数累加”，但结合组合数的计算目的和行走路径的约束条件，我们可以理解为x的每次递增象征着在已满足一定向下移动次数的基础上，对向右移动机会的累加计数。
     *
     *
     *
     *
     *
     * 组合逻辑在这里指的是计算组合数C(n, k)，即从n个不同元素中选取k个元素的组合方式数量。给定的Java代码片段实际上是以一种优化的方式计算了一个特定形式的组合数，即C(m+n-2, n-1)。下面详细介绍其实现逻辑：
     * 基础概念
     * 组合数C(n, k)的定义是： [ C(n, k) = \frac{n!}{k!(n-k)!} ] 其中"!"表示阶乘，即一个数到1的所有正整数的乘积。
     * 优化计算方法
     * 直接计算上述公式可能会遇到大数问题，尤其是当n或k较大时，阶乘的计算可能导致整数溢出。所给代码采用了另一种策略，通过逐步构造分子和分母来减少实际的乘除运算，并避免大数直接计算阶乘。
     *
     *
     *
     * 步骤解析：
     * 初始化:
     * long ret = 1; 初始化结果变量为1，因为任何数与1相乘都等于其本身，方便后续的累乘操作。
     * 循环逻辑:
     * 循环变量x初值设为n，y初值为1。这与直接计算C(m+n-2, n-1)的逻辑相对应，但通过逐步调整x和y，实际上是在动态构建组合数的分子和分母。
     * 每次循环中，ret = ret * x / y; 这一步是关键，它相当于在逐步构造组合数的计算过程，但避免了显式计算阶乘。实际上，这相当于逐步计算C(x+y-1, y)，
     * 因为每次循环都是基于前一次的结果乘以当前的x再除以y，这与组合数的连续性性质有关，即C(n, k) = C(n-1, k-1) * (n-k+1) / k。
     * x++ 和 y++ 分别增加向右和向下的步数计数，模拟逐步接近目标组合数的过程。
     * 结束条件:
     * 循环直到y < m不再成立，这意味着我们已经“走过”了(m-1)次向下，这与我们的目标——计算C(m+n-2, n-1)是一致的，因为我们是从第n次移动开始（即x=n），总共进行了(m+n-2)次移动的选择。
     * 结果转换与返回:
     * 最后，将长整型结果转换为整型并返回。这是基于假设结果能够安全转换为整数，且在实际应用中，路径数量确实是一个非负整数。
     *
     *
     * 总结
     * 这段代码通过动态调整累乘的分子和分母，以一种高效的计算方式实现了特定组合数的计算，避免了直接计算大数阶乘的开销和潜在的溢出问题。
     * 这种方法特别适合于计算大组合数，是组合数学中一种实用且高效的技巧。
     */
    public static int uniquePathsMath(int m, int n) {
        // write code here
        long ret = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            //组合公式的循环求解
            ret = ret * x / y;
        }
        return (int) ret;
    }
}
