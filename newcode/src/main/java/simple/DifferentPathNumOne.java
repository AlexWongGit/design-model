package simple;

import java.math.BigDecimal;

public class DifferentPathNumOne {

    public static void main(String[] args) {
        System.out.println(uniquePathsMath(59, 5));
    }

    public static int uniquePaths(int m, int n) {
        // write code here
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }

    /**
     * @param m
     * @param n
     * @return int
     * @description 这段Java代码实现的是计算组合数(Combination)的逻辑，具体是计算C(m+n-2, n-1)的值，这里采用了一种减少乘法和除法次数的优化方法，适用于当一个组合数的上标(或下标)远大于另一个时，可以减少计算中的整数溢出风险。下面是详细的逻辑解析：
     * 初始化:
     * 首先，定义并初始化一个长整型变量ret为1。这个变量将用来累计计算组合数的结果。
     * 循环变量设置:
     * 设置两个循环变量：x初始化为n，y初始化为1。这里的x和y实质上代表了组合公式中分母和分子的一部分，但通过循环逐步更新，实际上是在动态计算组合数的值。
     * 循环逻辑:
     * 循环的条件是y < m，意味着循环会执行(m-1)次，这对应于从(m+n-2)个位置中选择(n-1)个位置（或等效地，(m-1)次向下移动）的所有可能组合。
     * 在每次循环中，ret的值通过ret = ret * x / y更新。这个操作实际上是逐步构建组合数的分子和分母，但由于直接在累积结果上进行操作，避免了单独计算分子和分母的大数问题。
     * 每次循环后，x增加1，代表向右的步数累加；同时y也增加1，代表向下步数的累加，这与组合数的计算逻辑相符。
     * 结果转换与返回:
     * 循环结束后，将长整型变量ret转换成整型并返回。这是因为路径数量是一个非负整数，且在大多数情况下，计算结果应该能够安全地转换为整型。
     * 这种方法有效地减少了实际的乘除运算次数，并且在处理大数时比直接计算阶乘再相除的方式更稳定，降低了溢出的风险。整个逻辑基于组合数学中的性质，巧妙地通过迭代更新累乘结果来实现组合数的计算。
     * <p>
     * <p>
     * <p>
     * <p>
     * x初始化为n，每次循环加一，为什么代表向右的步数累加？
     * 在理解这个问题时，我们需要回顾一下组合问题的背景和这个特定函数的目的。该函数是用来计算一个m×n网格中，从左上角到右下角的不同行走路径数量。每一步只能向右或向下移动。
     * 当我们计算组合数C(m+n-2, n-1)时，这个表达式实际上是在寻找从(m+n-2)次移动中选择(n-1)次向下的方式数，剩下的(m-1)次自然就是向右的移动。但是，直接这么看可能与x的递增关联不明显，我们换个角度解释：
     * 初始时，x = n，可以理解为“起点”配置。因为我们是从(m+n-2)次总移动中选择，而这个总数已经隐含了起点（左上角）到终点（右下角）所需的最少步数，所以实际上是从第n次移动（即第一个可选的向右移动机会，因为在到达第一行的最右边之前，你必须至少向下走n-1次）开始考虑的。
     * 随着循环进行，x每次增加1，实际上就是在累加“额外的”向右移动次数。因为每次循环也同时增加了向下的移动次数（y递增），但我们的重点在于理解x的增长如何关联到向右移动。在这个上下文中，x的增长反映了在保证至少有(n-1)次向下移动的前提下，额外增加的向右移动机会。
     * 因此，虽然直接从代码中看x的递增可能不易直观联想到“向右的步数累加”，但结合组合数的计算目的和行走路径的约束条件，我们可以理解为x的每次递增象征着在已满足一定向下移动次数的基础上，对向右移动机会的累加计数。
     */
    public static int uniquePathsMath(int m, int n) {
        // write code here
        long ret = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            //组合公式的循环求解
            ret = ret * x / y;
        }
        return (int) ret;
    }
}
